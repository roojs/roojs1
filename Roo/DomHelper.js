/*
 * Based on:
 * Ext JS Library 1.1.1
 * Copyright(c) 2006-2007, Ext JS, LLC.
 *
 * Originally Released Under LGPL - original licence link has changed is not relivant.
 *
 * Fork - LGPL
 * <script type="text/javascript">
 */


// nasty IE9 hack - what a pile of crap that is..

 if (typeof Range != "undefined" && typeof Range.prototype.createContextualFragment == "undefined") {
    Range.prototype.createContextualFragment = function (html) {
        var doc = window.document;
        var container = doc.createElement("div");
        container.innerHTML = html;
        var frag = doc.createDocumentFragment(), n;
        while ((n = container.firstChild)) {
            frag.appendChild(n);
        }
        return frag;
    };
}

/**
 * @class Roo.DomHelper
 * Utility class for working with DOM and/or Templates. It transparently supports using HTML fragments or DOM.
 * For more information see <a href="http://web.archive.org/web/20071221063734/http://www.jackslocum.com/blog/2006/10/06/domhelper-create-elements-using-dom-html-fragments-or-templates/">this blog post with examples</a>.
 * @static
 */
Roo.DomHelper = function(){
    var tempTableEl = null;
    var emptyTags = /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i;
    var tableRe = /^table|tbody|tr|td$/i;
    var xmlns = {};
    // build as innerHTML where available
    /** @ignore */
    var createHtml = function(o){
        if(typeof o == 'string'){
            return o;
        }
        var b = "";
        if(!o.tag){
            o.tag = "div";
        }
        b += "<" + o.tag;
        for(var attr in o){
            if(attr == "tag" || attr == "children" || attr == "cn" || attr == "html" || typeof o[attr] == "function") { continue; }
            if(attr == "style"){
                var s = o["style"];
                if(typeof s == "function"){
                    s = s.call();
                }
                if(typeof s == "string"){
                    b += ' style="' + s + '"';
                }else if(typeof s == "object"){
                    b += ' style="';
                    for(var key in s){
                        if(typeof s[key] != "function"){
                            b += key + ":" + s[key] + ";";
                        }
                    }
                    b += '"';
                }
            }else{
                if(attr == "cls"){
                    b += ' class="' + o["cls"] + '"';
                }else if(attr == "htmlFor"){
                    b += ' for="' + o["htmlFor"] + '"';
                }else{
                    b += " " + attr + '="' + o[attr] + '"';
                }
            }
        }
        if(emptyTags.test(o.tag)){
            b += "/>";
        }else{
            b += ">";
            var cn = o.children || o.cn;
            if(cn){
                //http://bugs.kde.org/show_bug.cgi?id=71506
                if((cn instanceof Array) || (Roo.isSafari && typeof(cn.join) == "function")){
                    for(var i = 0, len = cn.length; i < len; i++) {
                        b += createHtml(cn[i], b);
                    }
                }else{
                    b += createHtml(cn, b);
                }
            }
            if(o.html){
                b += o.html;
            }
            b += "</" + o.tag + ">";
        }
        return b;
    };

    // build as dom
    /** @ignore */
    var createDom = function(o, parentNode){
         
        // defininition craeted..
        var ns = false;
        if (o.ns && o.ns != 'html') {
               
            if (o.xmlns && typeof(xmlns[o.ns]) == 'undefined') {
                xmlns[o.ns] = o.xmlns;
                ns = o.xmlns;
            }
            if (typeof(xmlns[o.ns]) == 'undefined') {
                console.log("Trying to create namespace element " + o.ns + ", however no xmlns was sent to builder previously");
            }
            ns = xmlns[o.ns];
        }
        
        
        if (typeof(o) == 'string') {
            return parentNode.appendChild(document.createTextNode(o));
        }
        o.tag = o.tag || div;
        if (o.ns && Roo.isIE) {
            ns = false;
            o.tag = o.ns + ':' + o.tag;
            
        }
        var el = ns ? document.createElementNS( ns, o.tag||'div') :  document.createElement(o.tag||'div');
        var useSet = el.setAttribute ? true : false; // In IE some elements don't have setAttribute
        for(var attr in o){
            
            if(attr == "tag" || attr == "ns" ||attr == "xmlns" ||attr == "children" || attr == "cn" || attr == "html" || 
                    attr == "style" || typeof o[attr] == "function") { continue; }
                    
            if(attr=="cls" && Roo.isIE){
                el.className = o["cls"];
            }else{
                if(useSet) { el.setAttribute(attr=="cls" ? 'class' : attr, o[attr]);}
                else { 
                    el[attr] = o[attr];
                }
            }
        }
        Roo.DomHelper.applyStyles(el, o.style);
        var cn = o.children || o.cn;
        if(cn){
            //http://bugs.kde.org/show_bug.cgi?id=71506
             if((cn instanceof Array) || (Roo.isSafari && typeof(cn.join) == "function")){
                for(var i = 0, len = cn.length; i < len; i++) {
                    createDom(cn[i], el);
                }
            }else{
                createDom(cn, el);
            }
        }
        if(o.html){
            el.innerHTML = o.html;
        }
        if(parentNode){
           parentNode.appendChild(el);
        }
        return el;
    };

    var ieTable = function(depth, s, h, e){
        tempTableEl.innerHTML = [s, h, e].join('');
        var i = -1, el = tempTableEl;
        while(++i < depth && el.firstChild){
            el = el.firstChild;
        }
        return el;
    };

    // kill repeat to save bytes
    var ts = '<table>',
        te = '</table>',
        tbs = ts+'<tbody>',
        tbe = '</tbody>'+te,
        trs = tbs + '<tr>',
        tre = '</tr>'+tbe;

    /**
     * @ignore
     * Nasty code for IE's broken table implementation
     */
    var insertIntoTable = function(tag, where, el, html){
        if(!tempTableEl){
            tempTableEl = document.createElement('div');
        }
        var node;
        var before = null;
        if(tag == 'td'){
            if(where == 'afterbegin' || where == 'beforeend'){ // INTO a TD
                return;
            }
            if(where == 'beforebegin'){
                before = el;
                el = el.parentNode;
            } else{
                before = el.nextSibling;
                el = el.parentNode;
            }
            node = ieTable(4, trs, html, tre);
        }
        else if(tag == 'tr'){
            if(where == 'beforebegin'){
                before = el;
                el = el.parentNode;
                node = ieTable(3, tbs, html, tbe);
            } else if(where == 'afterend'){
                before = el.nextSibling;
                el = el.parentNode;
                node = ieTable(3, tbs, html, tbe);
            } else{ // INTO a TR
                if(where == 'afterbegin'){
                    before = el.firstChild;
                }
                node = ieTable(4, trs, html, tre);
            }
        } else if(tag == 'tbody'){
            if(where == 'beforebegin'){
                before = el;
                el = el.parentNode;
                node = ieTable(2, ts, html, te);
            } else if(where == 'afterend'){
                before = el.nextSibling;
                el = el.parentNode;
                node = ieTable(2, ts, html, te);
            } else{
                if(where == 'afterbegin'){
                    before = el.firstChild;
                }
                node = ieTable(3, tbs, html, tbe);
            }
        } else{ // TABLE
            if(where == 'beforebegin' || where == 'afterend'){ // OUTSIDE the table
                return;
            }
            if(where == 'afterbegin'){
                before = el.firstChild;
            }
            node = ieTable(2, ts, html, te);
        }
        el.insertBefore(node, before);
        return node;
    };
    
    // this is a bit like the react update code...
    // 
    
    var updateNode = function(from, to)
    {
        // should we handle non-standard elements?
        
        if (from.nodeType != to.nodeType) {
            from.parentNode.replaceChild(to, from);
        }
        
        if (from.nodeType == 3) {
            // assume it's text?!
            if (from.data == to.data) {
                return;
            }
            from.data = to.data;
            return;
        }
        
        // assume 'to' doesnt have '1/3 nodetypes!
        if (from.nodeType !=1 || from.tagName != to.tagName) {
            from.parentNode.replaceChild(to, from);
            return;
        }
        // compare attributes
        var ar = Array.from(from.attributes);
        for(var i = 0; i< ar.length;i++) {
            if (to.hasAttribute(ar[i].name)) {
                continue;
            }
            from.removeAttribute(ar[i].name);
        }
        ar = to.attributes;
        for(var i = 0; i< ar.length;i++) {
            if (from.getAttribute(ar[i].name) == to.getAttribute(ar[i].name)) {
                continue;
            }
            from.setAttribute(ar[i].name, to.getAttribute(ar[i].name));
        }
        // children
        var far = Array.from(from.childNodes);
        var tar = Array.from(to.childNodes);
        // if the lengths are different.. then it's probably a editable content change, rather than
        // a change of the block definition..
        if (from.innerHTML == to.innerHTML) {
            return;
        }
        if (far.length != tar.length) {
            from.innerHTML = to.innerHTML;
            return;
        }
        
        for(var i = 0; i < far.length; i++) {
            updateNode(far[i], tar[i]);
        }
        
        
    };
    
    

    return {
        /** True to force the use of DOM instead of html fragments @type Boolean */
        useDom : false,
    
        /**
         * Returns the markup for the passed Element(s) config
         * @param {Object} o The Dom object spec (and children)
         * @return {String}
         */
        markup : function(o){
            return createHtml(o);
        },
    
        /**
         * Applies a style specification to an element
         * @param {String/HTMLElement} el The element to apply styles to
         * @param {String/Object/Function} styles A style specification string eg "width:100px", or object in the form {width:"100px"}, or
         * a function which returns such a specification.
         */
        applyStyles : function(el, styles){
            if(styles){
               el = Roo.fly(el);
               if(typeof styles == "string"){
                   var re = /\s?([a-z\-]*)\:\s?([^;]*);?/gi;
                   var matches;
                   while ((matches = re.exec(styles)) != null){
                       el.setStyle(matches[1], matches[2]);
                   }
               }else if (typeof styles == "object"){
                   for (var style in styles){
                      el.setStyle(style, styles[style]);
                   }
               }else if (typeof styles == "function"){
                    Roo.DomHelper.applyStyles(el, styles.call());
               }
            }
        },
    
        /**
         * Inserts an HTML fragment into the Dom
         * @param {String} where Where to insert the html in relation to el - beforeBegin, afterBegin, beforeEnd, afterEnd.
         * @param {HTMLElement} el The context element
         * @param {String} html The HTML fragmenet
         * @return {HTMLElement} The new node
         */
        insertHtml : function(where, el, html){
            where = where.toLowerCase();
            if(el.insertAdjacentHTML){
                if(tableRe.test(el.tagName)){
                    var rs;
                    if(rs = insertIntoTable(el.tagName.toLowerCase(), where, el, html)){
                        return rs;
                    }
                }
                switch(where){
                    case "beforebegin":
                        el.insertAdjacentHTML('BeforeBegin', html);
                        return el.previousSibling;
                    case "afterbegin":
                        el.insertAdjacentHTML('AfterBegin', html);
                        return el.firstChild;
                    case "beforeend":
                        el.insertAdjacentHTML('BeforeEnd', html);
                        return el.lastChild;
                    case "afterend":
                        el.insertAdjacentHTML('AfterEnd', html);
                        return el.nextSibling;
                }
                throw 'Illegal insertion point -> "' + where + '"';
            }
            var range = el.ownerDocument.createRange();
            var frag;
            switch(where){
                 case "beforebegin":
                    range.setStartBefore(el);
                    frag = range.createContextualFragment(html);
                    el.parentNode.insertBefore(frag, el);
                    return el.previousSibling;
                 case "afterbegin":
                    if(el.firstChild){
                        range.setStartBefore(el.firstChild);
                        frag = range.createContextualFragment(html);
                        el.insertBefore(frag, el.firstChild);
                        return el.firstChild;
                    }else{
                        el.innerHTML = html;
                        return el.firstChild;
                    }
                case "beforeend":
                    if(el.lastChild){
                        range.setStartAfter(el.lastChild);
                        frag = range.createContextualFragment(html);
                        el.appendChild(frag);
                        return el.lastChild;
                    }else{
                        el.innerHTML = html;
                        return el.lastChild;
                    }
                case "afterend":
                    range.setStartAfter(el);
                    frag = range.createContextualFragment(html);
                    el.parentNode.insertBefore(frag, el.nextSibling);
                    return el.nextSibling;
                }
                throw 'Illegal insertion point -> "' + where + '"';
        },
    
        /**
         * Creates new Dom element(s) and inserts them before el
         * @param {String/HTMLElement/Element} el The context element
         * @param {Object/String} o The Dom object spec (and children) or raw HTML blob
         * @param {Boolean} returnElement (optional) true to return a Roo.Element
         * @return {HTMLElement/Roo.Element} The new node
         */
        insertBefore : function(el, o, returnElement){
            return this.doInsert(el, o, returnElement, "beforeBegin");
        },
    
        /**
         * Creates new Dom element(s) and inserts them after el
         * @param {String/HTMLElement/Element} el The context element
         * @param {Object} o The Dom object spec (and children)
         * @param {Boolean} returnElement (optional) true to return a Roo.Element
         * @return {HTMLElement/Roo.Element} The new node
         */
        insertAfter : function(el, o, returnElement){
            return this.doInsert(el, o, returnElement, "afterEnd", "nextSibling");
        },
    
        /**
         * Creates new Dom element(s) and inserts them as the first child of el
         * @param {String/HTMLElement/Element} el The context element
         * @param {Object/String} o The Dom object spec (and children) or raw HTML blob
         * @param {Boolean} returnElement (optional) true to return a Roo.Element
         * @return {HTMLElement/Roo.Element} The new node
         */
        insertFirst : function(el, o, returnElement){
            return this.doInsert(el, o, returnElement, "afterBegin");
        },
    
        // private
        doInsert : function(el, o, returnElement, pos, sibling){
            el = Roo.getDom(el);
            var newNode;
            if(this.useDom || o.ns){
                newNode = createDom(o, null);
                el.parentNode.insertBefore(newNode, sibling ? el[sibling] : el);
            }else{
                var html = createHtml(o);
                newNode = this.insertHtml(pos, el, html);
            }
            return returnElement ? Roo.get(newNode, true) : newNode;
        },
    
        /**
         * Creates new Dom element(s) and appends them to el
         * @param {String/HTMLElement/Element} el The context element
         * @param {Object/String} o The Dom object spec (and children) or raw HTML blob
         * @param {Boolean} returnElement (optional) true to return a Roo.Element
         * @return {HTMLElement/Roo.Element} The new node
         */
        append : function(el, o, returnElement){
            el = Roo.getDom(el);
            var newNode;
            if(this.useDom || o.ns){
                newNode = createDom(o, null);
                el.appendChild(newNode);
            }else{
                var html = createHtml(o);
                newNode = this.insertHtml("beforeEnd", el, html);
            }
            return returnElement ? Roo.get(newNode, true) : newNode;
        },
    
        /**
         * Creates new Dom element(s) and overwrites the contents of el with them
         * @param {String/HTMLElement/Element} el The context element
         * @param {Object/String} o The Dom object spec (and children) or raw HTML blob
         * @param {Boolean} returnElement (optional) true to return a Roo.Element
         * @return {HTMLElement/Roo.Element} The new node
         */
        overwrite : function(el, o, returnElement)
        {
            el = Roo.getDom(el);
            if (o.ns) {
              
                while (el.childNodes.length) {
                    el.removeChild(el.firstChild);
                }
                createDom(o, el);
            } else {
                el.innerHTML = createHtml(o);   
            }
            
            return returnElement ? Roo.get(el.firstChild, true) : el.firstChild;
        },
    
        /**
         * Creates a new Roo.DomHelper.Template from the Dom object spec
         * @param {Object} o The Dom object spec (and children)
         * @return {Roo.DomHelper.Template} The new template
         */
        createTemplate : function(o){
            var html = createHtml(o);
            return new Roo.Template(html);
        },
         /**
         * Updates the first element with the spec from the o (replacing if necessary)
         * This iterates through the children, and updates attributes / children etc..
         * @param {String/HTMLElement/Element} el The context element
         * @param {Object/String} o The Dom object spec (and children) or raw HTML blob
         */
        
        update : function(el, o)
        {
            updateNode(Roo.getDom(el), createDom(o));
            
        }
        
        
    };
}();
